(ns use-cases.tutorial-processes.combine-tutorial
  (:require 
   [clojure.core.async.flow :as flow]
   [clojure.string :as str]
   [adapters.logging.log :as l]
   [clojure.java.io :as io]))

(defn- create-safe-filename
  "Create a safe filename from a chapter name"
  [chapter-num chapter-name]
  (let [safe-name (-> chapter-name
                      (str/lower-case)
                      (str/replace #"[^a-z0-9]+" "_"))]
    (format "%02d_%s.md" chapter-num safe-name)))

(defn- create-mermaid-diagram
  "Create a mermaid diagram showing relationships between abstractions"
  [abstractions relationships]
  (let [mermaid-lines ["flowchart TD"]
        ;; Add nodes
        node-lines 
        (map-indexed 
         (fn [i abstraction]
           (let [node-id (str "A" i)
                 ;; Sanitize name for mermaid
                 node-label (-> (:name abstraction)
                              (str/replace "\"" ""))]
             (format "    %s[\"%s\"]" node-id node-label)))
         abstractions)
        ;; Add relationships
        rel-lines
        (map 
         (fn [rel]
           (let [from-id (str "A" (:from rel))
                 to-id (str "A" (:to rel))
                 ;; Sanitize and truncate label
                 edge-label (-> (:label rel)
                              (str/replace "\"" "")
                              (str/replace "\n" " ")
                              (str/trim))]
             (format "    %s -- \"%s\" --> %s" 
                    from-id 
                    (if (> (count edge-label) 30)
                      (str (subs edge-label 0 27) "...")
                      edge-label)
                    to-id)))
         (:details relationships))]
    (str/join "\n" (concat mermaid-lines node-lines rel-lines))))

(defn- create-index-content
  "Create the content for index.md"
  [{:keys [project-name relationships abstractions chapter-order repo-url]}]
  (let [mermaid-diagram (create-mermaid-diagram abstractions relationships)
        ;; Create chapter listing
        chapter-listing 
        (str/join "\n"
                  (map-indexed
                   (fn [i abstraction-idx]
                     (let [chapter-num (inc i)
                           abstraction (get abstractions abstraction-idx)
                           chapter-name (:name abstraction)
                           filename (create-safe-filename chapter-num chapter-name)]
                       (format "%d. [%s](%s)" chapter-num chapter-name filename)))
                   chapter-order))]
    (str "# Tutorial: " project-name "\n\n"
         (:summary relationships) "\n\n"
         (when repo-url
           (str "**Source Repository:** [" repo-url "](" repo-url ")\n\n"))
         "```mermaid\n"
         mermaid-diagram "\n"
         "```\n\n"
         "## Chapters\n\n"
         chapter-listing "\n\n"
         "---\n\n"
         "Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)")))

(defn combine-tutorial!
  "Combine all chapters into a complete tutorial"
  [{:keys [project-name relationships abstractions chapter-order chapters repo-url]} output-dir]
  (let [;; Create output directory path
        project-dir (str output-dir "/" project-name)
        index-file (io/file project-dir "index.md")
        _ (io/make-parents index-file)
        
        ;; Create and write index.md
        index-content (create-index-content 
                      {:project-name project-name
                       :relationships relationships
                       :abstractions abstractions
                       :chapter-order chapter-order
                       :repo-url repo-url})
        _ (spit index-file index-content)
        
        ;; Write each chapter file
        _ (doall
           (map-indexed
            (fn [i abstraction-idx]
              (let [chapter-num (inc i)
                    abstraction (get abstractions abstraction-idx)
                    chapter-name (:name abstraction)
                    filename (create-safe-filename chapter-num chapter-name)
                    chapter-file (io/file project-dir filename)
                    _ (io/make-parents chapter-file)
                    chapter-content (str (nth chapters i) "\n\n"
                                       "---\n\n"
                                       "Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)")]
                (spit chapter-file chapter-content)))
            chapter-order))]
    ;; Return the output directory path
    project-dir))

(defn write-to-files!
  "Process that combines all chapters into a complete tutorial"
  ([] {:params {:output-dir "output"}
       :ins {:chapters "Generated chapter content"}
       :outs {:final-output-dir "Path to the final generated tutorial directory"}})

  ;; init
  ([args] (assoc args :ready true :output-dir "output"))

  ;; transition
  ([state transition]
   (case transition
     ::flow/resume
     (assoc state :ready true)

     ::flow/pause
     (assoc state :ready false)

     ::flow/stop
     (assoc state :ready false)
     
     state))

  ;; transform
  ([state in msg]
   (if (and (= in :chapters) (:ready state))
     (let [
           output-dir (get state :output-dir "output")
           final-dir (combine-tutorial! 
                      (select-keys msg [:project-name :language :abstractions :chapter-order :chapters]) output-dir)]
       (l/log "Tutorial generation complete! Files are in:" final-dir)
       [state {:final-output-dir [final-dir]}])
     [state nil])))